tibsize marker.i2c i2c.detect i2c.7bitaddr? i2c.m!n@ i2c.n@ i2c.n! i2c.c! i2c.c@ i2c.end i2c.begin-read i2c.begin i2c.rd i2c.wr i2c.ping? i2c.status i2c.rxn i2c.rx i2c.tx i2c.action i2c.restart i2c.stop i2c.start i2c.wait i2c.init.default i2c.init i2c.sta i2c.ea i2c.int i2c.conf.prescaler i2c.prescaler/64 i2c.prescaler/16 i2c.prescaler/4 i2c.prescaler/1 i2c.off i2c.timeout? i2c.current i2c.loop i2c.maxticks i2c.timeout Evalue pin_pullup_on pin_pullup_off toggle pin@ pin_low? pin_high? pin_input pin_output pin! wait_high_all wait_low is_high? is_low? pulse low high portpin: bitmask: <builds base-and-tools evaluate [evaluate] (evaluate) source-string str strlen imove is edump idump split dump .4hex .2hex ?ascii X ; : local local! local@ l> >l l-alloc l-free l! l@ l-init lsp l-size base-system buffer: find count source-id move */mod sm/rem fm/mod .res source-string str strlen erase environment? [environment?] (environment?) imove .( chars char+ c, blank align aligned 2swap 2over empty test-wl marker order get-order dump edump idump dump> <dump trimm .addr .rcells .ecells .icells ? e? i? .item u.r marker ?pairs ?comp ?throw compile, foo range endcase endof of case noop >body s>d spaces space cr bounds ?stack tolower toupper turnkey bl hex decimal bin allot here ehere dp key? key emit? emit pad >in tuck 2drop 2dup cells base state f_cpu fill s" ." words show-wordlist within max min mod / negate u/mod u.r u. (defer) defer@ defer! Udefer! Udefer@ Rdefer! Rdefer@ Edefer! Edefer@ throw catch handler warm cold pause quit .input .error .ready .ok cell+ pick abs /mod dinvert d- d+ d2/ d2* nr> n>r -1 2 1 = 2literal @i (!i-nrww) !i @e !e 2r> 2>r up! up@ >< cmove> unloop i sp! sp@ rp! rp@ +! rshift lshift ?negate 1- 1+ xor or and 2* 2/ invert um* um/mod m* + - log2 > < u> u< 0 true d0< d0> 0> 0< 0= <> r@ >r r> nip rot drop over swap ?dup dup !u @u c@ c! ! @ (value) execute exit applturnkey postpone (marker) end-code code forth-wordlist wordlist set-current int-trap int@ int! -int +int #int irq[]# nfa>lfa compare cfg-recs cfg-order get-current map-stack set-stack get-stack ?abort abort abort" [char] immediate recurse user constant variable [ ] ; :noname : does> reveal wlscope header create lp lp0 >l l> endloop ?do leave +loop loop do again until repeat while begin then else if ahead sliteral literal ['] , compile ( \ (create-in) (create) latest newest find-xt nfa>cfa name>string traverse-wordlist search-wordlist rectype-null rectype-xt rec-find rec-num rectype-dnum rectype-num interpret recognize forth-recognizer depth rp0 sp0 parse-name /string source parse >number number char refill accept cscan cskip ' type icount itype s, digit? ud/mod ud.r ud. . d. .r d.r sign #> #s # <# hold hld environment init-ram ee>ram #tib tib source-tib refill-tib 2swap cmove dnegate dabs j * icompare i-cell+ to unused ver 1ms name>flags umin umax ud* m+ 1w.slot 1w.reset +usart ubrr tx?-poll tx-poll rx?-buf rx-buf isr-rx >rx-buf
